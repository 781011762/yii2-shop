<?php
namespace backend\models;

use yii\web\IdentityInterface;

/**
 * This is the model class for table "admin".
 *
 * @property integer $id
 * @property string $username
 * @property string $auth_key
 * @property string $password_hash
 * @property string $password_reset_token
 * @property string $email
 * @property integer $status
 * @property integer $created_at
 * @property integer $updated_at
 * @property integer $last_login_time
 * @property string $last_login_ip
 */
class Admin extends \yii\db\ActiveRecord implements IdentityInterface
{
	public $password;
	public $roles;
	//定义常量 场景
	const SCENARIO_ADD = 'add';
	const SCENARIO_EDIT = 'edit';
    /**
     * @inheritdoc
     */
    public static function tableName()
    {
        return 'admin';
    }

    public function getAllRoles(){
	    $allRoles = array_keys(\Yii::$app->authManager->getRoles());
	    $roles = [];
	    if ($allRoles){
		    foreach ($allRoles as $v){
			    $roles[$v] = $v;
		    }
	    }
	    return $roles;
    }
    /**
     * @inheritdoc
     */
    public function rules()
    {
        return [
            [['username', 'email','status'], 'required'],
            [['username', 'password',], 'string', 'max' => 255],
	        [['username', 'email'], 'unique'],//
	        ['roles','safe'],//角色
	        [['password'],'required','on'=>self::SCENARIO_ADD]//只在on定义的场景生效
        ];
    }

    /**
     * @inheritdoc
     */
    public function attributeLabels()
    {
        return [
            'id' => 'ID',
            'username' => '管理员',
            'auth_key' => '认证码',
            'password' => '密码',
            'password_hash' => '密码',
            'password_reset_token' => '密码重置令牌',
            'email' => '邮箱',
            'status' => '状态',
            'created_at' => '创建日期',
            'updated_at' => '修改日期',
            'last_login_time' => '最后登录时间',
            'last_login_ip' => '最后登录IP',
            'roles' => '身份',
        ];
    }

	public function beforeSave($insert)//重写save前执行的代码
	{//$insert 修改 返回false
		if ($insert){//添加  加密 添加时间 auth_key
			$this->password_hash = \Yii::$app->security->generatePasswordHash($this->password);
			$this->created_at = time();
			$this->auth_key = \Yii::$app->security->generateRandomString();
		}else{//修改
			if ($this->password){//如果修改密码 加密保存 生成新的 auth_key
				$this->password_hash = \Yii::$app->security->generatePasswordHash($this->password);
			}
			$this->auth_key = \Yii::$app->security->generateRandomString();
			$this->updated_at = time();
		}
		return parent::beforeSave($insert); // TODO: Change the autogenerated stub
	}

	public function addRoles(){
		if ($this->roles){//添加角色身份
			$auth = \Yii::$app->authManager;
			foreach ($this->roles as $v){
				$auth->assign($auth->getRole($v),$this->id);
			}
		}
	}
	//修改角色
	public function editRoles(){
		$auth = \Yii::$app->authManager;
		$oldRoles = array_keys($auth->getRolesByUser($this->id));
		if ($this->roles==null){
			$newRoles = [];
		}else{
			$newRoles = $this->roles;
		}
		$delRoles = array_diff_assoc($oldRoles,$newRoles);
		$addRoles = array_diff_assoc($newRoles,$oldRoles);
		if ($delRoles){
			foreach ($delRoles as $v){
				$auth->revoke($auth->getRole($v),$this->id);
			}
		}
		if ($addRoles){
			foreach ($addRoles as $v){
				$auth->assign($auth->getRole($v),$this->id);
			}
		}
	}
	//获得导航栏
	public function getMenuItems(){
		$models = NavList::find()->where(['parent_id'=>0])->all();//获得所有一级菜单
		$menuS = [];
		if ($models){//找到了一级菜单
			foreach ($models as $model){
				$items = [];
				$menus = NavList::find()->where(['parent_id'=>$model->id])->all();
				if ($menus){//找到了二级菜单
					foreach ($menus as $menu){
						if ($menu->url){
							if (\Yii::$app->user->can($menu->url)){
								$items[] = ['label'=>$menu->name,'url'=>[$menu->url]];
							}
						}//这里没有url的二级菜单不显示选项
					}
				}
				if ($items!=null){
					$menuS[] = ['label'=>$model->name,'items'=>$items];
				}
			}
		}
		return $menuS;
	}

	/**
	 * Finds an identity by the given ID.
	 * @param string|int $id the ID to be looked for
	 * @return IdentityInterface the identity object that matches the given ID.
	 * Null should be returned if such an identity cannot be found
	 * or the identity is not in an active state (disabled, deleted, etc.)
	 */
	public static function findIdentity($id)
	{
		return self::findOne($id);
	}

	/**
	 * Finds an identity by the given token.
	 * @param mixed $token the token to be looked for
	 * @param mixed $type the type of the token. The value of this parameter depends on the implementation.
	 * For example, [[\yii\filters\auth\HttpBearerAuth]] will set this parameter to be `yii\filters\auth\HttpBearerAuth`.
	 * @return IdentityInterface the identity object that matches the given token.
	 * Null should be returned if such an identity cannot be found
	 * or the identity is not in an active state (disabled, deleted, etc.)
	 */
	public static function findIdentityByAccessToken($token, $type = null)
	{
		// TODO: Implement findIdentityByAccessToken() method.
	}

	/**
	 * Returns an ID that can uniquely identify a user identity.
	 * @return string|int an ID that uniquely identifies a user identity.
	 */
	public function getId()
	{
		return $this->id;
	}

	/**
	 * Returns a key that can be used to check the validity of a given identity ID.
	 *
	 * The key should be unique for each individual user, and should be persistent
	 * so that it can be used to check the validity of the user identity.
	 *
	 * The space of such keys should be big enough to defeat potential identity attacks.
	 *
	 * This is required if [[User::enableAutoLogin]] is enabled.
	 * @return string a key that is used to check the validity of a given identity ID.
	 * @see validateAuthKey()
	 */
	public function getAuthKey()
	{
		// TODO: Implement getAuthKey() method.
		return $this->auth_key;
	}

	/**
	 * Validates the given auth key.
	 *
	 * This is required if [[User::enableAutoLogin]] is enabled.
	 * @param string $authKey the given auth key
	 * @return bool whether the given auth key is valid.
	 * @see getAuthKey()
	 */
	public function validateAuthKey($authKey)
	{
		// TODO: Implement validateAuthKey() method.
		return $authKey == $this->auth_key;
	}
}
